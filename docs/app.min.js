// Crisis Management Dashboard - Simplified Frontend (clean)
console.log('[CrisisDashboard] simplified clean version 2025-12-24');

class CrisisDashboard {
      // Local fallback: always return synthetic data for requested symbols
      async fetchStockQuotes(symbols) {
        // In local/dev mode, just return synthetic data
        return this.syntheticStockSample(symbols);
      }
    getWatchlistTickers() {
      // Extract up to 6 non-empty, trimmed, uppercased ticker symbols from the stock input fields
      const inputs = Array.from(document.querySelectorAll('#stockForm .stock-input'));
      return inputs
        .map(i => String(i.value || '').trim().toUpperCase())
        .filter(s => s.length > 0)
        .slice(0, 6);
    }
  constructor() {
    this.events = [];
    this.currentFilter = 'all';
    this.dataUrl = 'events.json';
    const defaultDisplay = 80; const slow=150, fast=6, min=0, max=100; const ratio = Math.max(0, Math.min(1, (defaultDisplay - min) / (max - min))); const d = Math.round(slow - ratio * (slow - fast));
    this._clearTickerDuration();
    this.tickerDuration = d; // lock to 80 on every load
    this.tickerConfig = { freshness_hours: 72, max_items: 20 };
    this.lastEventLoadAttempts = [];
    // Stocks auto-refresh state
    this.autoRefreshTimer = null;
    this.rateLimitStreak = 0;
    this.init();
  }

  async init() {
    this.setupEventListeners();
    // Kick off event load and add a failsafe to clear a stuck spinner
    await this.loadEvents();
    this.clearLoadingIfStuck();
    this.renderDiagnostics();
  }

  setupEventListeners() {
    const filterButtons = document.querySelectorAll('.filter-btn');
    filterButtons.forEach(btn => {
      btn.addEventListener('click', (e) => {
        const target = e.currentTarget;
        const level = target && target.dataset ? target.dataset.level : 'all';
        this.handleFilterChange(level);
        filterButtons.forEach(b => b.classList.remove('active'));
        target.classList.add('active');
      });
    });

    const controls = document.getElementById('tickerControls');
    if (controls) {
      controls.addEventListener('click', (e) => {
        const target = e.target;
        if (!(target instanceof HTMLElement)) return;
        const action = target.dataset.action;
        if (action === 'slower') this.adjustTickerSpeed(1);
        else if (action === 'faster') this.adjustTickerSpeed(-1);
        else if (action === 'reset') this.resetTickerSpeed();
      });
    }

    // Stock watchlist events
    const fetchBtn = document.getElementById('fetchStocksBtn');
    if (fetchBtn) fetchBtn.addEventListener('click', () => this.fetchAndRenderStocks());
    const clearBtn = document.getElementById('clearStocksBtn');
    if (clearBtn) clearBtn.addEventListener('click', () => this.clearStocks());
    // Manual fetch only: no auto-submit on Enter
    const remember = document.getElementById('rememberWatchlist');
    if (remember) {
      remember.addEventListener('change', () => {
        this.saveWatchlistIfOpted();
      });
    }

    // Prefill watchlist inputs: saved (if opted) else defaults KO, MCD
    this.prefillWatchlistInputs();

    // Retry loading events from the loading area
    const retryLoadBtn = document.getElementById('retryLoadBtn');
    if (retryLoadBtn) {
      retryLoadBtn.addEventListener('click', async () => {
        const loadingEl = document.getElementById('loading');
        const errorEl = document.getElementById('error');
        if (errorEl) errorEl.style.display = 'none';
        if (loadingEl) loadingEl.style.display = 'block';
        // Failsafe in case retry fetch stalls
        this.clearLoadingIfStuck(6000);
        try {
          await this.loadEvents();
        } finally {
          if (loadingEl) loadingEl.style.display = 'none';
        }
      });
    }
  }

  async loadEvents() {
    const loadingEl = document.getElementById('loading');
    const errorEl = document.getElementById('error');
    const eventsEl = document.getElementById('events');
    let attempts = [];
    try {
      if (loadingEl) loadingEl.style.display = 'block';
      if (errorEl) errorEl.style.display = 'none';
      if (eventsEl) eventsEl.innerHTML = '';

      let data = null;
      const url = this.dataUrl;
      try {
        const response = await this.fetchWithTimeout(url, 6000);
        if (response && response.ok) {
          const text = await response.text();
          let json = null;
          try { json = JSON.parse(text); } catch {}
          if (json && json.contents) {
            try { data = JSON.parse(json.contents); } catch { data = null; }
          } else {
            data = json;
          }
          if (data) attempts.push({ url, ok: true });
        } else {
          attempts.push({ url, ok: false, status: (response && response.status) || 'timeout' });
        }
      } catch (e) {
        attempts.push({ url, ok: false, error: String(e) });
      }

      if (!data) {
        const msg = attempts.map(a => `‚Ä¢ ${a.url} ‚Üí ${a.ok ? 'OK' : (a.status ? 'HTTP '+a.status : a.error || 'error')}`).join('\n');
        const err = new Error('Failed to load events. Attempts:\n' + msg);
        err.attempts = attempts;
        throw err;
      }

      this.lastEventLoadAttempts = attempts;
      this.events = data.events || [];
      this.tickerConfig = data.ticker_config || { freshness_hours: 72, max_items: 20 };
      this.updateLastUpdated(data.last_updated);
      this.updateStats();
      this.renderEvents();
      this.renderTicker();
      if (loadingEl) loadingEl.style.display = 'none';
      this.renderDiagnostics();
      this.renderStatusBadge();
    } catch (error) {
      console.error('Error loading events:', error);
      if (loadingEl) loadingEl.style.display = 'none';
      if (errorEl) errorEl.style.display = 'block';
      this.showErrorBanner(error, attempts);
      this.lastEventLoadAttempts = attempts;
      try {
        this.events = [];
        this.updateStats();
        this.renderEvents();
        this.renderTicker();
      } catch (_) {}
      this.renderDiagnostics();
      this.renderStatusBadge();
    }
  }

  // Failsafe: if the loading spinner remains visible due to an unexpected state,
  // hide it and surface a message so the UI is not blocked.
  clearLoadingIfStuck(timeoutMs = 5000) {
    const loadingEl = document.getElementById('loading');
    const errorEl = document.getElementById('error');
    if (!loadingEl) return;
    setTimeout(() => {
      try {
        const isVisible = loadingEl.style.display !== 'none';
        // Also check computed style in case inline style didn‚Äôt update
        const computed = window.getComputedStyle(loadingEl);
        const actuallyVisible = isVisible || computed.display !== 'none';
        if (actuallyVisible) {
          loadingEl.style.display = 'none';
          if (errorEl && errorEl.style.display !== 'block') {
            errorEl.style.display = 'block';
            errorEl.innerHTML = '<p>‚ùå Loading took too long. Please try again.</p>';
          }
        }
      } catch (_) {}
    }, timeoutMs);
  }

  updateLastUpdated(timestamp) {
    const updateTimeEl = document.getElementById('updateTime');
    if (timestamp && updateTimeEl) updateTimeEl.textContent = new Date(timestamp).toLocaleString();
  }

  updateStats() {
    const stats = { total: this.events.length, critical: 0, high: 0, medium: 0, low: 0 };
    this.events.forEach(event => {
      const level = (event.severity_level || '').toLowerCase();
      if (Object.prototype.hasOwnProperty.call(stats, level)) stats[level]++;
    });
    const setText = (id, val) => { const el = document.getElementById(id); if (el) el.textContent = String(val); };
    setText('totalEvents', stats.total);
    setText('criticalCount', stats.critical);
    setText('highCount', stats.high);
    setText('mediumCount', stats.medium);
  }

  handleFilterChange(level) { this.currentFilter = level; this.renderEvents(); }

  renderEvents() {
    const eventsEl = document.getElementById('events');
    const noEventsEl = document.getElementById('noEvents');
    if (!eventsEl || !noEventsEl) return;
    let filteredEvents = this.events;
    // Only show events within the last 24 hours, most recent first, for all severity filters
    const levels = ['critical', 'high', 'medium', 'low'];
    if (levels.includes((this.currentFilter || '').toLowerCase())) {
      const now = Date.now();
      const level = this.currentFilter;
      filteredEvents = this.events.filter(e => {
        if ((e.severity_level || '').toLowerCase() !== level.toLowerCase()) return false;
        const t = Date.parse(e.published || 0) || 0;
        return t && (now - t <= 24 * 60 * 60 * 1000);
      });
      filteredEvents.sort((a, b) => (Date.parse(b.published || 0) || 0) - (Date.parse(a.published || 0) || 0));
    } else if (this.currentFilter !== 'all') {
      filteredEvents = this.events.filter(e => e.severity_level === this.currentFilter);
    }
    if (!filteredEvents.length) { eventsEl.style.display = 'none'; noEventsEl.style.display = 'block'; return; }
    eventsEl.style.display = 'grid'; noEventsEl.style.display = 'none';
    eventsEl.innerHTML = filteredEvents.map(event => this.createEventCard(event)).join('');
  }

  createEventCard(event) {
    const severityClass = (event.severity_level || 'Low').toLowerCase();
    const description = this.truncateText(event.description || '', 200);
    const publishedDate = this.formatDate(event.published);
    const title = this.escapeHtml(event.title || 'Untitled');
    const url = this.escapeHtml(event.url || '#');
    const source = this.escapeHtml(event.source || '');
    const score = event.severity_score ?? 0;
    return (
      `<div class="event-card ${severityClass}">
        <div class="event-header">
          <h2 class="event-title"><a href="${url}" target="_blank" rel="noopener noreferrer">${title}</a></h2>
          <span class="severity-badge ${severityClass}">${event.severity_level || 'Low'}</span>
        </div>
        <p class="event-description">${this.escapeHtml(description)}</p>
        <div class="event-meta">
          <span class="event-source">üì∞ ${source}</span>
          <span class="event-date">üïí ${publishedDate}</span>
          <span class="score">Score: ${score}</span>
        </div>
      </div>`
    );
  }

  truncateText(text, maxLength) { if (!text) return 'No description available.'; return text.length <= maxLength ? text : text.substring(0, maxLength).trim() + '...'; }

  formatDate(dateString) {
    if (!dateString) return 'Unknown date';
    try {
      const date = new Date(dateString);
      const now = new Date();
      const diffMs = now - date;
      const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
      const diffDays = Math.floor(diffHours / 24);
      if (diffHours < 1) return 'Just now';
      if (diffHours < 24) return `${diffHours}h ago`;
      if (diffDays < 7) return `${diffDays}d ago`;
      return date.toLocaleDateString();
    } catch { return 'Unknown date'; }
  }

  escapeHtml(text) { const div = document.createElement('div'); div.textContent = text; return div.innerHTML; }

  renderTicker() {
    const bar = document.getElementById('ticker');
    const track = document.getElementById('tickerTrack');
    const emptyBanner = document.getElementById('tickerEmptyBanner');
    const widenBtn = document.getElementById('widenTickerWindowBtn');
    const resetBtn = document.getElementById('resetTickerWindowBtn');
    if (!bar || !track) return;
    const items = this.getTickerItems(this.events);
    if (!items.length) {
      // Show fallback ticker with current date/time and advice
      bar.style.display = 'block';
      if (emptyBanner) emptyBanner.style.display = 'flex';
      document.body.classList.add('ticker-active');
      document.body.classList.add('banner-active');
      const windowHours = this.tickerConfig?.ticker_window_hours ?? 2;
      const alt = this.getFallbackTickerItems(windowHours);
      const altHtml = alt.map(i => `<span class="ticker-item"><a href="${this.escapeHtml(i.url || '#')}" target="_blank" rel="noopener noreferrer">${this.escapeHtml(i.label || '')}</a><span class="ticker-sep">‚Ä¢</span></span>`).join('');
      track.innerHTML = altHtml + altHtml;
      this.applyTickerSpeed();
      this.updateSpeedLabel();
      if (widenBtn) {
        widenBtn.onclick = () => {
          // Expand window to 6 hours and re-render
          this.tickerConfig = Object.assign({}, this.tickerConfig, { ticker_window_hours: 6 });
          // Recompute items and rerender
          const next = this.getTickerItems(this.events);
          if (next.length) {
            if (emptyBanner) emptyBanner.style.display = 'none';
            document.body.classList.remove('banner-active');
            bar.style.display = 'block';
            document.body.classList.add('ticker-active');
            const html = next.map(i => `<span class="ticker-item"><a href="${this.escapeHtml(i.url || '#')}" target="_blank" rel="noopener noreferrer">${this.escapeHtml(i.label || '')}</a><span class="ticker-sep">‚Ä¢</span></span>`).join('');
            track.innerHTML = html + html;
            this.applyTickerSpeed();
            this.updateSpeedLabel();
          } else {
            // Still empty: keep fallback
            if (emptyBanner) emptyBanner.style.display = 'flex';
            document.body.classList.add('banner-active');
            bar.style.display = 'block';
            document.body.classList.add('ticker-active');
            const alt2 = this.getFallbackTickerItems(6);
            const altHtml2 = alt2.map(i => `<span class=\"ticker-item\"><a href=\"${this.escapeHtml(i.url || '#')}\" target=\"_blank\" rel=\"noopener noreferrer\">${this.escapeHtml(i.label || '')}</a><span class=\"ticker-sep\">‚Ä¢</span></span>`).join('');
            track.innerHTML = altHtml2 + altHtml2;
            this.applyTickerSpeed();
            this.updateSpeedLabel();
          }
        };
      }
      if (resetBtn) {
        resetBtn.onclick = () => {
          // Reset window to 2 hours and re-render
          this.tickerConfig = Object.assign({}, this.tickerConfig, { ticker_window_hours: 2 });
          const next = this.getTickerItems(this.events);
          if (!next.length) {
            // Still empty: keep fallback
            if (emptyBanner) emptyBanner.style.display = 'flex';
            document.body.classList.add('banner-active');
            bar.style.display = 'block';
            document.body.classList.add('ticker-active');
            const alt2 = this.getFallbackTickerItems(2);
            const altHtml2 = alt2.map(i => `<span class=\"ticker-item\"><a href=\"${this.escapeHtml(i.url || '#')}\" target=\"_blank\" rel=\"noopener noreferrer\">${this.escapeHtml(i.label || '')}</a><span class=\"ticker-sep\">‚Ä¢</span></span>`).join('');
            track.innerHTML = altHtml2 + altHtml2;
            this.applyTickerSpeed();
            this.updateSpeedLabel();
          } else {
            // Items now present
            if (emptyBanner) emptyBanner.style.display = 'none';
            document.body.classList.remove('banner-active');
            bar.style.display = 'block';
            document.body.classList.add('ticker-active');
            const html2 = next.map(i => `<span class=\"ticker-item\"><a href=\"${this.escapeHtml(i.url || '#')}\" target=\"_blank\" rel=\"noopener noreferrer\">${this.escapeHtml(i.label || '')}</a><span class=\"ticker-sep\">‚Ä¢</span></span>`).join('');
            track.innerHTML = html2 + html2;
            this.applyTickerSpeed();
            this.updateSpeedLabel();
          }
        };
      }
      return;
    }
    // Items present: ensure banner hidden
    if (emptyBanner) emptyBanner.style.display = 'none';
    document.body.classList.remove('banner-active');
    bar.style.display = 'block';
    document.body.classList.add('ticker-active');
    const html = items.map(i => `<span class="ticker-item"><a href="${this.escapeHtml(i.url || '#')}" target="_blank" rel="noopener noreferrer">${this.escapeHtml(i.label || '')}</a><span class="ticker-sep">‚Ä¢</span></span>`).join('');
    track.innerHTML = html + html;
    this.applyTickerSpeed();
    this.updateSpeedLabel();
  }

  getTickerItems(events) {
    const maxItems = this.tickerConfig?.max_items ?? 20;
    // Use configurable window; default to 2 hours
    const windowHours = this.tickerConfig?.ticker_window_hours ?? 2;
    const now = Date.now(); const seen = new Set(); const items = [];
    const isFresh = (published) => { const t = Date.parse(published || 0) || 0; if (!published || Number.isNaN(t)) return false; const ageHours = (now - t) / (1000 * 60 * 60); return ageHours <= windowHours; };
    for (const e of events) {
      // Only include Critical severity in the news scroll
      if ((e.severity_level || '').toLowerCase() !== 'critical') continue;
      if (!isFresh(e.published)) continue;
      let label = e.ticker_label || null; let category = e.ticker_category || null; const url = e.url;
      const text = `${e.title || ''} ${e.description || ''}`.toLowerCase();
      if (!label || !category) {
        if (this.isAirlineDisaster(text)) { label = `‚úàÔ∏è ${e.title}`; category = 'airline_disaster'; }
        else if (this.isNaturalDisaster(text)) { label = `üå™Ô∏è ${e.title}`; category = 'natural_disaster'; }
        else if (this.isWar(text)) { label = `ü™ñ ${e.title}`; category = 'war'; }
        else if (this.isTerrorism(text)) { label = `üí• ${e.title}`; category = 'terrorism'; }
        else if (this.isActiveShooter(text)) { label = `üö® ${e.title}`; category = 'active_shooter'; }
        else if (this.isMassCasualty(text, 10)) { label = `üöë ${e.title}`; category = 'mass_casualty'; }
        else if (this.isStockSwing(text, 50)) { label = `üìà ${e.title}`; category = 'stock_swing'; }
      }
      if (label) {
        // Stock swings are irrelevant here since we gate by Critical severity, but keep extra freshness guard if ever used
        if (category === 'stock_swing') { const t = Date.parse(e.published || 0) || 0; const ageHours = (Date.now() - t) / (1000 * 60 * 60); if (!(ageHours <= 12)) continue; }
        const key = label.toLowerCase().replace(/\s+/g, ' ').trim(); if (seen.has(key)) continue; seen.add(key);
        items.push({ label, url }); if (items.length >= maxItems) break;
      }
    }
    return items;
  }

  // Fallback items when no Critical events within window
  getFallbackTickerItems(windowHours = 2) {
    const nowStr = new Date().toLocaleString();
    const msgs = [
      `‚è∞ ${nowStr} ‚Ä¢ Continuous Monitoring Active. No Critical Events in the last ${windowHours} Hours.`,
      'üåü Stay prepared; small actions save lives.',
      'üß≠ Verify sources; act responsibly.',
      'ü§ù Check in on your community.',
      'üí° Keep an emergency kit stocked.',
      'ü´∂ Breathe and focus; you‚Äôve got this.'
    ];
    return msgs.map(m => ({ label: m, url: '#' }));
  }

  isAirlineDisaster(text) { const hasAviation = /(airline|aircraft|flight|plane|jet|aviation|airport)\b/.test(text); const hasCrash = /(crash|downed|mid-?air|collision|fell|plunged)/.test(text); const hasSevere = /(fatal|fatalities|killed|dead|emergency landing)/.test(text); return hasAviation && (hasCrash || hasSevere); }
  isNaturalDisaster(text) { return /(earthquake|tremor|tsunami|hurricane|cyclone|typhoon|tornado|wildfire|bushfire|wild fire|flood|landslide|mudslide|volcano|eruption|storm)\b/.test(text); }
  isWar(text) { return /(war|invasion|frontline|airstrike|strike|missile|shelling|bombardment|offensive|counteroffensive|ceasefire)\b/.test(text); }
  isTerrorism(text) { return /(terror|terrorist|bomb|bombing|suicide bomber|ied|extremist attack)\b/.test(text); }
  isActiveShooter(text) { return /(shooting|shooter|gunman|shots? fired|mass shooting)\b/.test(text); }
  isMassCasualty(text, threshold = 10) { const hasWords = /(mass casualty|death toll|multiple fatalities)\b/.test(text); const re = /(?:dead|killed|deaths|casualties|fatalities)\s*:?\s*(\d+)/g; let high = false, m; while ((m = re.exec(text)) !== null) { const n = parseInt(m[1], 10); if (!Number.isNaN(n) && n >= threshold) { high = true; break; } } return hasWords || high; }
  isStockSwing(text, threshold = 50) { const hasFinance = /(stock|shares|market|price|ticker|exchange|nasdaq|nyse)\b/.test(text); let swing = false; const re = /(-?\d{1,3})\s*%/g; let m; while ((m = re.exec(text)) !== null) { const pct = Math.abs(parseInt(m[1], 10)); if (!Number.isNaN(pct) && pct >= threshold) { swing = true; break; } } return hasFinance && swing; }

  adjustTickerSpeed(direction) { const minDisp=0, maxDisp=100, step=5; const current = this.getDisplaySpeed(); const delta = (direction === 1 ? -step : step); const nextDisp = Math.max(minDisp, Math.min(maxDisp, current + delta)); this.setDisplaySpeed(nextDisp); }
  resetTickerSpeed() { this.setDisplaySpeed(100); }
  setDisplaySpeed(display) { const slow=150, fast=6, min=0, max=100; const ratio = Math.max(0, Math.min(1, (Number(display) - min) / (max - min))); const d = slow - ratio * (slow - fast); this.tickerDuration = Math.round(d); this.applyTickerSpeed(); this.updateSpeedLabel(); this._saveTickerDuration(this.tickerDuration); }
  getDisplaySpeed() { const d = Number(this.tickerDuration) || 0; const slow=150, fast=6, min=0, max=100; const ratio = (slow - d) / (slow - fast); let mapped = min + Math.max(0, Math.min(1, ratio)) * (max - min); return Math.round(mapped); }
  updateSpeedLabel() { const label = document.getElementById('tickerSpeedLabel'); if (!label) return; const v = this.getDisplaySpeed(); let emoji = ''; if (v > 80) emoji = 'üêá'; else if (v < 20) emoji = 'üê¢'; label.innerHTML = `Speed: ${v}${emoji ? ' <span class=\"speed-emoji\">'+emoji+'</span>' : ''}`; }
  applyTickerSpeed() { const track = document.getElementById('tickerTrack'); if (!track) return; const factor = 0.8; const effective = this.tickerDuration * factor; track.style.setProperty('--ticker-duration', `${effective}s`); track.style.animationDuration = `${effective}s`; const name = window.getComputedStyle(track).animationName || 'ticker-scroll'; track.style.animationName = 'none'; void track.offsetWidth; track.style.animationName = name; }
  _saveTickerDuration(seconds) { try { /* disabled to keep storage tidy */ } catch (_) {} }
  _clearTickerDuration() { try { localStorage.removeItem('tickerDuration'); } catch (_) {} }
  _loadTickerDuration() { try { const v = localStorage.getItem('tickerDuration'); const n = v ? parseInt(v, 10) : NaN; if (!Number.isNaN(n)) return n; } catch (_) {} return null; }

  async fetchWithTimeout(url, ms = 4000) { const controller = new AbortController(); const id = setTimeout(() => controller.abort(), ms); try { const res = await fetch(url, { signal: controller.signal }); return res; } catch { return null; } finally { clearTimeout(id); } }
  showErrorBanner(error, attempts) { const errorEl = document.getElementById('error'); if (!errorEl) return; errorEl.innerHTML = '<p>‚ùå Unable to load events. Please try again later.</p>'; const banner = document.createElement('div'); banner.className = 'error-banner'; const message = error && error.message ? error.message : 'An unknown error occurred.'; const listItems = (attempts || []).map(a => { const status = a.ok ? 'OK' : (a.status ? `HTTP ${a.status}` : (a.error || 'error')); const href = a.url || ''; return `<li><a class="error-link" href="${href}" target="_blank" rel="noopener">${href}</a> ‚Äî ${status}</li>`; }).join(''); banner.innerHTML = `<div><strong>Failed to load events.</strong> ${this.escapeHtml(message)}</div>${attempts && attempts.length ? `<ul>${listItems}</ul>` : ''}<div class="error-actions"><button type="button" class="retry-btn" aria-label="Retry loading events">Retry</button></div>`; errorEl.appendChild(banner); const retryBtn = banner.querySelector('.retry-btn'); if (retryBtn) { retryBtn.addEventListener('click', async () => { banner.remove(); errorEl.style.display = 'none'; const loadingEl = document.getElementById('loading'); if (loadingEl) loadingEl.style.display = 'block'; try { await this.loadEvents(); } finally { if (loadingEl) loadingEl.style.display = 'none'; } }); } }
  isLocalEnv() { try { return typeof window !== 'undefined' && /^(localhost|127\.0\.0\.1)$/i.test(window.location.hostname); } catch (_) { return false; } }
  renderDiagnostics() { try { const box = document.getElementById('diagnostics'); const content = document.getElementById('diagContent'); if (!box || !content) return; const params = new URLSearchParams(window.location.search); const enabled = params.get('debug') === '1'; box.style.display = enabled ? 'block' : 'none'; if (!enabled) return; const isLocal = this.isLocalEnv(); const attemptLines = (this.lastEventLoadAttempts || []).map(a => `${a.ok ? 'OK' : 'ERR'} ${a.status ? '('+a.status+')' : ''} ‚Üí ${a.url}`); const nowStr = new Date().toLocaleString(); content.innerHTML = [`Time: ${this.escapeHtml(nowStr)}`, `Env: ${isLocal ? 'local' : 'prod-like'}`, `Event load attempts:`, `<ul>${attemptLines.map(l => `<li>${this.escapeHtml(l)}</li>`).join('')}</ul>`].join('<br>'); } catch(_) {} }
  renderStatusBadge() { try { const el = document.getElementById('statusBadge'); if (!el) return; const isLocal = this.isLocalEnv(); const pills = []; pills.push(`<span class="badge-pill"><span class="dot"></span> Env: ${isLocal ? 'local' : 'prod-like'}</span>`); el.innerHTML = pills.join(' '); } catch(_) {} }

  // --- Stocks ---
  getProxyBase() { return 'http://127.0.0.1:8001'; }
  showStockInfo(message, type = 'info') {
    const box = document.getElementById('stockInfo');
    if (!box) return;
    box.className = `stock-info ${type}`;
    // Set message text without removing timestamp element
    box.firstChild && box.firstChild.nodeType === Node.TEXT_NODE ? (box.firstChild.nodeValue = message + ' ') : (box.innerHTML = message + ' <span id="stockInfoTime" class="stock-info-time"></span>');
    const timeEl = document.getElementById('stockInfoTime');
      if (widenBtn) {
      const now = new Date();
      const mins = this.nextRefreshAt ? Math.max(1, Math.round((this.nextRefreshAt - Date.now())/60000)) : null;
      const nextMsg = mins ? ` ‚Ä¢ Next refresh in ${mins} min` : '';
      timeEl.textContent = `${now.toLocaleString()} üïí Last Updated${nextMsg}`;
    }
  }
  prefillWatchlistInputs() {
    const inputs = Array.from(document.querySelectorAll('#stockForm .stock-input'));
    const remember = document.getElementById('rememberWatchlist');
    const shouldRemember = remember ? remember.checked : this._loadRememberFlag();
    if (remember) remember.checked = !!shouldRemember;
    let symbols = [];
    if (shouldRemember) {
      symbols = this._loadSavedWatchlist();
    }
    if (!symbols || symbols.length === 0) {
      symbols = ['KO', 'MCD'];
    }
    for (let i = 0; i < inputs.length; i++) {
      inputs[i].value = symbols[i] || '';
    }
  }

  async fetchSingleQuote(symbol) {
    const base = this.getProxyBase();
    const url = `${base}/yahoo/quote?symbols=${encodeURIComponent(symbol)}`;
    const res = await this.fetchWithTimeout(url, 6000);
    if (!res || !res.ok) return null;
    let data = null; try { data = await res.json(); } catch { return null; }
    const r = data && data.quoteResponse && Array.isArray(data.quoteResponse.result) ? data.quoteResponse.result[0] : null;
    if (!r) return null;
    const symbolOut = r.symbol || symbol;
    const name = r.shortName || r.longName || symbolOut;
    const price = typeof r.regularMarketPrice === 'number' ? r.regularMarketPrice : null;
    const pct = typeof r.regularMarketChangePercent === 'number' ? r.regularMarketChangePercent : null;
    return { symbol: symbolOut, name, price, pct };
  }

  async fetchChartPrice(symbol) {
    const base = this.getProxyBase();
    const url = `${base}/yahoo/chart?symbol=${encodeURIComponent(symbol)}`;
    const res = await this.fetchWithTimeout(url, 6000);
    if (!res || !res.ok) return null;
    let data = null; try { data = await res.json(); } catch { return null; }
    const meta = data && data.chart && data.chart.result && data.chart.result[0] && data.chart.result[0].meta;
    const price = meta && typeof meta.regularMarketPrice === 'number' ? meta.regularMarketPrice : null;
    if (price == null) return null;
    return { symbol, name: symbol, price, pct: null };
  }
  formatPrice(n) { if (n == null || Number.isNaN(Number(n))) return '‚Äî'; return Number(n).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 }); }
  formatPct(n) {
    if (n == null || Number.isNaN(Number(n))) return '‚Äî';
    const v = Number(n);
    const s = (v > 0 ? '+' : (v < 0 ? '' : '')) + v.toFixed(2) + '%';
    return s;
  }
  renderStockPrices(items) {
    const list = document.getElementById('stockPrices');
    if (!list) return;
    if (!items.length) {
      list.innerHTML = '<li class="stock-price-item"><span class="stock-symbol">No tickers</span><span class="stock-value">Enter symbols and click Update</span></li>';
      return;
    }
    // Sort by percent change descending; nulls last
    const sorted = items.slice().sort((a, b) => {
      const ap = typeof a.pct === 'number' ? a.pct : -Infinity;
      const bp = typeof b.pct === 'number' ? b.pct : -Infinity;
      return bp - ap;
    });
    list.innerHTML = sorted.map(q => {
      const price = this.formatPrice(q.price);
      const pct = typeof q.pct === 'number' ? q.pct : null;
      const cls = pct == null ? '' : (pct >= 0 ? 'up' : 'down');
      const pctStr = this.formatPct(pct);
      const name = this.escapeHtml(q.name || '');
      const sym = this.escapeHtml(q.symbol || '');
      const dollar = `<span class="currency ${cls}" aria-hidden="true">$</span>`;
      return `<li class="stock-price-item"><span class="stock-symbol" title="${name}">${sym}</span><span class="stock-value">${dollar}${price}</span><span class="stock-change ${cls}">${pctStr}</span></li>`;
    }).join('');
  }

  async fetchAndRenderStocks() {
    const symbols = this.getWatchlistTickers();
    this.clearAutoRefresh();
    const list = document.getElementById('stockPrices');
    if (!symbols.length) {
      this.showStockInfo('Enter ticker symbols, then click Fetch Prices.', 'info');
      if (list) list.innerHTML = '<li class="stock-price-item"><span class="stock-symbol">No tickers</span><span class="stock-value">Add symbols on the right</span></li>';
      return;
    }
    let quotes = [];
    let usedBatch = false, usedSingle = false, usedChart = false;
    // Try batch fetch first
    quotes = await this.fetchStockQuotes(symbols);
    usedBatch = Array.isArray(quotes) && quotes.length > 0;
    // If batch fails, try single/price fallback for each
    if (!usedBatch) {
      quotes = [];
      for (const sym of symbols) {
        let q = await this.fetchSingleQuote(sym);
        if (q) { usedSingle = true; }
        if (!q) { q = await this.fetchChartPrice(sym); if (q) usedChart = true; }
        if (q) quotes.push(q);
        // Small delay to be polite
        await new Promise(r => setTimeout(r, 250));
      }
    }
    // Local dev fallback: sample data if remote is rate-limited
    if ((!quotes || quotes.length === 0) && this.isLocalEnv()) {
      const sample = await this.loadLocalStockSample(symbols);
      if (sample && sample.length) quotes = sample;
    }
    // Ensure all requested symbols appear (fill missing via sample/synthetic in local dev)
    if (this.isLocalEnv() && Array.isArray(quotes) && quotes.length > 0) {
      const have = new Set(quotes.map(q => String(q.symbol || '').toUpperCase()));
      const missing = symbols.filter(s => !have.has(s.toUpperCase()));
      if (missing.length) {
        const fillers = this.syntheticStockSample(missing);
        quotes = quotes.concat(fillers);
      }
    }
    if (!quotes || quotes.length === 0) {
      if (list) list.innerHTML = '<li class="stock-price-item"><span class="stock-symbol">Fetch error</span><span class="stock-value">Rate limited or unavailable</span></li>';
      this.showStockInfo('Rate limited or unavailable. Please try again later.', 'error');
      this.scheduleNextRefresh(true);
      return;
    }
    this.renderStockPrices(quotes);
    if (usedBatch) this.showStockInfo(`Fetched ${quotes.length} price${quotes.length > 1 ? 's' : ''} via proxy.`, 'success');
    else if (usedSingle || usedChart) this.showStockInfo(`Proxy rate-limited. Fetched ${quotes.length} via fallback${usedChart ? ' (price only; % change may be unavailable)' : ''}.`, 'warning');
    else this.showStockInfo('Using local sample data for development.', 'info');
    const rateLimited = !(usedBatch || usedSingle || usedChart);
    this.scheduleNextRefresh(rateLimited);
    this.saveWatchlistIfOpted();
  }
  scheduleNextRefresh(rateLimited) {
    // Auto-refresh only when not fully rate-limited; otherwise back off politely
    const base = 60000; // 60s
    const backoff1 = 180000; // 3m
    const backoff2 = 300000; // 5m
    if (!rateLimited) {
      this.rateLimitStreak = 0;
      this.setAutoRefresh(base);
      return;
    }
    this.rateLimitStreak = Math.min(2, this.rateLimitStreak + 1);
    const delay = this.rateLimitStreak === 1 ? backoff1 : backoff2;
    this.setAutoRefresh(delay);
  }
  setAutoRefresh(ms) {
    this.clearAutoRefresh();
    this.nextRefreshAt = Date.now() + ms;
    this.autoRefreshTimer = setTimeout(() => {
      this.fetchAndRenderStocks();
    }, ms);
  }
  clearAutoRefresh() { if (this.autoRefreshTimer) { clearTimeout(this.autoRefreshTimer); this.autoRefreshTimer = null; } this.nextRefreshAt = null; }

  async loadLocalStockSample(symbols) {
    try {
      const res = await this.fetchWithTimeout('/data/stocks_sample.json', 2000);
      if (!res || !res.ok) return this.syntheticStockSample(symbols);
      const data = await res.json();
      const all = Array.isArray(data.quotes) ? data.quotes : [];
      const map = new Map(all.map(q => [String(q.symbol || '').toUpperCase(), q]));
      const out = [];
      const missing = [];
      for (const s of symbols) {
        const sym = String(s).toUpperCase();
        const q = map.get(sym);
        if (q) out.push(q); else missing.push(sym);
      }
      if (missing.length) {
        // Add synthetic fallback for any missing symbols
        out.push(...this.syntheticStockSample(missing));
      }
      return out;
    } catch { return this.syntheticStockSample(symbols); }
  }
  syntheticStockSample(symbols) {
    // Deterministic pseudo-values for local-only fallback
    const out = [];
    for (const s of symbols) {
      let hash = 0; for (let i=0;i<s.length;i++) { hash = ((hash<<5)-hash) + s.charCodeAt(i); hash |= 0; }
      const base = 100 + (Math.abs(hash)%150);
      const pct = ((hash%500)/100) - 2.5; // approx -2.5%..+2.5%
      out.push({ symbol: s, name: s, price: Number(base.toFixed(2)), pct: Number(pct.toFixed(2)) });
    }
    return out;
  }
  clearStocks() {
    const inputs = Array.from(document.querySelectorAll('#stockForm .stock-input'));
    inputs.forEach(i => { i.value = ''; });
    const list = document.getElementById('stockPrices');
    if (list) list.innerHTML = '';
  }
}

if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => { new CrisisDashboard(); }); } else { new CrisisDashboard(); }
